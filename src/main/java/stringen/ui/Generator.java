package stringen.ui;

import java.util.ArrayList;
import java.util.HashMap;

import javafx.collections.ObservableList;
import javafx.scene.control.ListView;
import javafx.scene.layout.HBox;
import stringen.logic.AndGroup;
import stringen.logic.Cohort;
import stringen.logic.LogicManager;
import stringen.logic.OrGroup;
import stringen.logic.SingleOrGroup;
import stringen.logic.requirements.Requirement;
import stringen.logic.requirements.RequirementList;
import stringen.ui.exceptions.InvalidInputException;

public class Generator {

    /**
     * Creates cohorts and passes them to LogicManager to generate string.
     * @param entryWindows <code>EntryWindow</code>s that contain information for each cohort.
     * @return String generated by LogicManager.
     * @throws InvalidInputException If any invalid inputs are found when parsing information entered into the cohorts.
     */
    public String generateString(ArrayList<EntryWindow> entryWindows) throws InvalidInputException {
        ArrayList<Cohort> cohorts = new ArrayList<>();
        for (EntryWindow entryWindow: entryWindows) {
            Cohort cohort = getCohort(entryWindow);
            ArrayList<OrGroup> orGroups = createGroups(entryWindow);
            cohort.addOrGroups(orGroups);
            cohorts.add(cohort);
        }
        return LogicManager.generateString(cohorts);
    }

    /**
     * Obtains the input start year and end year and creates a new cohort.
     * @param entryWindow <code>EntryWindow</code> that contains the information for one cohort.
     * @return New cohort with input start year and end year.
     */
    public Cohort getCohort(EntryWindow entryWindow) {
        ListView<HBox> listContent = entryWindow.getListContent();
        CohortListCard cohortCard = (CohortListCard) listContent.getItems().get(1);
        return new Cohort(cohortCard.getStartYear(), cohortCard.getEndYear());
    }

    /**
     * Collates the list of OrGroups to be added to a cohort.
     * @param entryWindow <code>EntryWindow</code> contains all information for one cohort.
     * @return List of OrGroups to be added to a cohort.
     * @throws InvalidInputException If #createRequirementGroup() parses an invalid input.
     */
    private ArrayList<OrGroup> createGroups(EntryWindow entryWindow) throws InvalidInputException {
        ListView<HBox> listContent = entryWindow.getListContent();
        ObservableList<HBox> items = listContent.getItems();

        // to skip all the starting headers (including cohort years)
        int startingIndex = 0;
        while (startingIndex < items.size() && !isRequirementLine(items.get(startingIndex))) {
            startingIndex++;
        }

        int i = startingIndex + 1;
        ArrayList<OrGroup> orGroups = new ArrayList<>();

        boolean hasMoreRequirements = true;
        while (i < items.size() && hasMoreRequirements) {
            int endingIndexForRequirement = i + 1;
            while (endingIndexForRequirement < items.size()
                    && !((EntryFieldCard) items.get(endingIndexForRequirement)).isNewRequirement()) {
                endingIndexForRequirement++;
            }

            boolean isLastRequirement = endingIndexForRequirement == items.size();
            if (isLastRequirement) {
                hasMoreRequirements = false;
            }

            OrGroup orGroup = createRequirementGroup(i, endingIndexForRequirement, items);
            if (orGroup != null) {
                orGroups.add(orGroup);
            }
            i = endingIndexForRequirement;
        }
        return orGroups;
    }

    /**
     * Creates a new OrGroup for each numbered requirement.
     * @param requirementHeaderIndex Starting index of requirement.
     * @param endingIndexForRequirement Ending index of requirement (not inclusive).
     * @param items List of individual inputs.
     * @return OrGroup containing all inputs in one requirement.
     * @throws InvalidInputException if #createOrGroup() parses an invalid input.
     */
    private OrGroup createRequirementGroup(int requirementHeaderIndex, int endingIndexForRequirement,
                                           ObservableList<HBox> items) throws InvalidInputException {
        ArrayList<ArrayList<OrGroup>> listOfOrGroups = createListsOfOrGroups(requirementHeaderIndex, endingIndexForRequirement, items);

        ArrayList<ArrayList<OrGroup>> listOfOrGroupsAfterCombining = new ArrayList<>();
        for (int j = 0; j < listOfOrGroups.size(); j++) {
            ArrayList<OrGroup> group = listOfOrGroups.get(j);
            listOfOrGroupsAfterCombining.add(combineSinglesIntoLists(group));
        }

        ArrayList<AndGroup> andGroups = new ArrayList<>();
        for (int k = 0; k < listOfOrGroupsAfterCombining.size(); k++) {
            andGroups.add(new AndGroup(listOfOrGroups.get(k)));
        }
        if (andGroups.isEmpty()) {
            return null;
        }

        return new OrGroup(andGroups);
    }

    /**
     * Creates lists of OrGroups for each section in a requirement separated by an "OR" label.
     * @param requirementHeaderIndex Starting index of the requirement.
     * @param endingIndexForRequirement Ending index of the requirement (not inclusive).
     * @param items List of individual inputs.
     * @return List of lists of OrGroups.
     */
    private ArrayList<ArrayList<OrGroup>> createListsOfOrGroups(int requirementHeaderIndex, int endingIndexForRequirement,
                                                                ObservableList<HBox> items) {
        ArrayList<ArrayList<OrGroup>> listOfOrGroups = new ArrayList<>();
        int i = requirementHeaderIndex;
        boolean isNewConjunction = true;

        while (i < endingIndexForRequirement) {
            EntryFieldCard entryFieldCard = (EntryFieldCard) items.get(i);
            OrGroup newOrGroup = createOrGroup(entryFieldCard);
            if (newOrGroup == null) {
                i++;
                continue;
            }
            if (isNewConjunction) {
                ArrayList<OrGroup> newOrGroupList = new ArrayList<>();
                newOrGroupList.add(newOrGroup);
                listOfOrGroups.add(newOrGroupList);
                isNewConjunction = false;
            } else {
                ArrayList<OrGroup> currentOrGroup = listOfOrGroups.get(listOfOrGroups.size() - 1);
                currentOrGroup.add(newOrGroup);
            }

            if (entryFieldCard.containsOrLabel()) {
                isNewConjunction = true;
            }

            i++;
        }
        return listOfOrGroups;
    }

    private OrGroup createOrGroup(EntryFieldCard entry) throws InvalidInputException {
        Requirement requirement = entry.getResponses();
        if (requirement == null) {
            return null;
        }
        return new SingleOrGroup(requirement);
    }

    /**
     * Checks if an orGroup is a <code>SingleOrGroup</code> that contains a requirement list that only contains one
     * other requirement. These requirement lists can be combined with other requirement lists of the same type.
     * @param orGroup Individual input line.
     * @return Whether this input was a requirement list.
     */
    private boolean isSingleRequirementList(OrGroup orGroup) {
        return orGroup instanceof SingleOrGroup &&
                ((SingleOrGroup) orGroup).getRequirement() instanceof RequirementList &&
                ((RequirementList)((SingleOrGroup) orGroup).getRequirement()).getRequirements().size() == 1;
    }

    /**
     * Combines all <code>SingleOrGroup</code>s in the same section that is also are also requirement lists
     * into one requirement list.
     * @param orGroups OrGroups that are all in the same section in a requirement that is separated by an "OR".
     * @return OrGroups after combining requirement lists.
     */
    public ArrayList<OrGroup> combineSinglesIntoLists(ArrayList<OrGroup> orGroups) {
        HashMap<String, ArrayList<RequirementList>> requirementListHashMap = new HashMap<>();
        ArrayList<OrGroup> singles = new ArrayList<>();
        for (int i = 0; i < orGroups.size(); i++) {
            OrGroup orGroup = orGroups.get(i);
            if (isSingleRequirementList(orGroup)) {
                RequirementList requirementList = ((RequirementList)((SingleOrGroup) orGroup).getRequirement());
                if (requirementList.wasMcRequirement) {
                    continue;
                }
                String prefix = requirementList.getPrefix();
                if (requirementListHashMap.containsKey(prefix)) {
                    requirementListHashMap.get(prefix).add(requirementList);
                } else {
                    ArrayList<RequirementList> requirementLists = new ArrayList<>();
                    requirementLists.add(requirementList);
                    requirementListHashMap.put(prefix, requirementLists);
                }
                singles.add(orGroup);
            }
        }
        orGroups.removeAll(singles);

        for (String prefix : requirementListHashMap.keySet()) {
            ArrayList<RequirementList> requirementLists = requirementListHashMap.get(prefix);
            ArrayList<Requirement> requirements = new ArrayList<>();
            for (int i = 0; i < requirementLists.size(); i++) {
                requirements.addAll(requirementLists.get(i).getRequirements());
            }
            orGroups.add(new SingleOrGroup(new RequirementList(requirements, requirements.size(), prefix)));
        }
        return orGroups;
    }

    /**
     * Checks if this line contains a new requirement label. This indicates that the next line will belong to a new
     * requirement.
     * @param hBox Individual input line.
     * @return Whether the next line is part of another requirement.
     */
    private boolean isRequirementLine(HBox hBox) {
        if (hBox.getChildren().size() == 1) {
            if (hBox instanceof TitleListCard) {
                TitleListCard title = (TitleListCard) hBox;
                return title.isRequirementLine();
            }
        }
        return false;
    }

}
